Caesar Cipher:

#include <iostream>
using namespace std;
int main()
{
    string cipher,plain,plain2;
    cipher = "";
    plain="";
    plain2="";
    int n,cn,key;
    
    cout << ("Enter the plain text:");
    getline(cin,plain);
    cout << ("Enter the key");
    cin >> key;
    
    for(int i =0;i<plain.length();i++){
        n = (int)(plain[i]);
        if(65<=n && n<=90){
            cn = (n+key-65)%26;
            cipher+=(cn+65);
        }
        else if(97<=n && n<=122){
            cn  = (n+key-97)%26;
            cipher+= (cn+97);
        }
        
        else{
            cipher+= n;
        }
    }
    
    cout << cipher<<endl;
        
    for(int i =0;i<cipher.length();i++){
        n = (int)(cipher[i]);
        if(65<=n && n<=90){
            cn = (n-key-65);
            if (cn < 0) {
                cn = 26+cn;
            }
            plain2+= (cn+65);
        }
        else if(97<=n && n<=122){
            cn  = (n-key-97);
            if (cn < 0) {
                cn = 26+cn;
            }
            plain2+= (cn+97);
        }
        
        else{
            plain2+= n;
        }
    }
    cout << plain2<<endl;

    return 0;
}




Playfair Cipher:



#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <cctype>
 
using namespace std;
 
string encrypt(string text);
string decrypt(string text);
void createKeyMatrix(string key);
void findInMatrix(char letter, int &row, int &col);
string createPairs(string input);
string removeX(string text);
 
char keyMatrix[5][5];
int originallen ;
 
void output() {
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j)
            cout << keyMatrix[i][j] << " ";
        cout << "\n";
    }
}
 
int main() {
    string input, key, option;
    cout << "key:\n";
    // create key matrix first
    getline(cin, key);
    createKeyMatrix(key);
    output();
        cout << "input:\n";
        getline(cin, input);
        originallen = input.length();
        input = createPairs(input);
        cout << input << endl;
        string enc = encrypt(input);
        cout << enc<< endl;
        cout << removeX(decrypt(enc)) << endl;

}
 
int mod(int a, int b) {
    // C version of '%' is a remainder function not modulo
    // so we must implement our own mod function
    int r = a % b;
    return r < 0 ? r + b : r;
}
 
void replace(string &text, int pos, char from, char to) {
    if (text[pos] == from)   text[pos] = to;
    if (text[pos+1] == from) text[pos+1] = to;
}
 
void findInMatrix(char letter, int &row, int &col) {
    for (int r = 0; r < 5; ++r)
        for (int c = 0; c < 5; ++c)
            if (letter == keyMatrix[r][c]) {
                row = r; col = c;
                return;
            }
}
 
string encrypt(string text) {
    string output = "";
    int row1, col1, row2, col2;
    int size = text.length();
    for (int pos = 0; pos < size; pos += 2) {
        replace(text, pos, 'j', 'i');
 
        // get position of pairs in the matrix
        findInMatrix(text[pos], row1, col1);
        findInMatrix(text[pos+1], row2, col2);
 
        // same row -> shift to the right mod 5
        if (row1 == row2) {
            output += keyMatrix[row1][mod(col1+1, 5)];
            output += keyMatrix[row2][mod(col2+1, 5)];
        }
 
        // same col -> shift down mod 5
        else if (col1 == col2) {
            output += keyMatrix[mod(row1+1, 5)][col1];
            output += keyMatrix[mod(row2+1, 5)][col2];
        }
 
        // diagonal -> swap columns
        else {
            output += keyMatrix[row1][col2];
            output += keyMatrix[row2][col1];
        }
    }
    return output;
}
 
string decrypt(string text) {
    string output = "";
    int row1, col1, row2, col2;
    int size = text.length();
    for (int pos = 0; pos < size; pos += 2) {
        // get position of pairs in the matrix
        findInMatrix(text[pos], row1, col1);
        findInMatrix(text[pos+1], row2, col2);
 
        // same row -> shift to the right mod 5
        if (row1 == row2) {
            output += keyMatrix[row1][mod(col1-1, 5)];
            output += keyMatrix[row2][mod(col2-1, 5)];
        }
        // same col -> shift down mod 5
        else if (col1 == col2) {
            output += keyMatrix[mod(row1-1, 5)][col1];
            output += keyMatrix[mod(row2-1, 5)][col2];
        }
        // diagonal -> swap columns
        else {
            output += keyMatrix[row1][col2];
            output += keyMatrix[row2][col1];
        }
    }
    return output;
}
 
string removeX(string text) {
    string original = "";
    original += text[0];
    int size = text.length();
 
    // start at 1 and stop at size-1 since we access i-1 AND i+1
    // we do this becase an 'x' will never be at the 0th index
    // aa -> axa
    for (int i = 1; i < size-1; ++i) {
        if (!(text[i] == 'x' && text[i-1] == text[i+1]))
            original += text[i];
    }
 
    if ((originallen%2==0)){
        original+=text[size-1];
    }
    
    return original;
}
 
 
// return whether the letter c has already been used
bool found(char c, vector<char> used) {
    return find(used.begin(), used.end(), c) != used.end();
}
 
void createKeyMatrix(string key) {
    vector<char> used; // stores used letters
    used.push_back('j');
    int size = key.length();
    int count = 0;
    char fillLetter = 'a';
 
    for (int row = 0; row < 5; ++row)
        for (int col = 0; col < 5; ++col) {
            if (count < size) { // insert key stage
                char letter = key[count];
                if (!found(letter, used)) {
                    keyMatrix[row][col] = letter;
                    used.push_back(letter);
                }
                else --col; // lag back try next letter
                ++count;
            }
            else { // fill matrix when key is inserted
                if (!found(fillLetter, used))
                    keyMatrix[row][col] = fillLetter;
                else --col; // lag behind
                ++fillLetter;
            }
        }
}
 
string createPairs(string input) {
    string newString = "";
    int size = input.length();
 
    // start at 1 to prevent index out of bounds exception
    // also makes it easier to dodge spaces this way
    for (int i = 1; i < size; ++i) {
        if (!isspace(input[i-1])) {
            newString += input[i-1];
            // if there is a repeat 'aa' then add 'axa'
            if (input[i-1] == input[i])
                newString += 'x';
        }
    }
 
    // size - 1 is missed because we read i - 1 and not i
    newString += input[size-1];
    if ((newString.length() & 1) == 1)
        newString += 'x';
    return newString;
}






Hill Cipher:

#include<bits/stdc++.h>
using namespace std;
char arr[26];

vector< pair<int,int> > enc,vec;

int findPos(char ch){
	for(int i=0;i<26;i++){
		if(ch==arr[i])
			return i;
	}
	return -1;
}

void encryption(string msg,int key[][2]){
	string cipher = "";
	pair<int,int> temp;
	for(int i=0;i<msg.length()-1;i+=2)
	{
		temp.first = findPos(msg[i]);
		temp.second = findPos(msg[i+1]);
		vec.push_back(temp);
	}
	for(int x=0;x<vec.size();x++){
		int t1 = key[0][0]*vec[x].first + key[0][1]*vec[x].second;
		int p1 = t1%26;
		int t2 = key[1][0]*vec[x].first + key[1][1]*vec[x].second;
		int p2 = t2%26;
		temp.first = t1; temp.second = t2;
		enc.push_back(temp);
		char c1 = char(65+p1);
		char c2 = char(65+p2);
		cipher += c1;
		cipher += c2;
	}
	cout<<"cipher text is: "<<cipher;
}

void decryption(int Inv[2][2])
{
	string P;
	int det = Inv[0][0]*Inv[1][1] - Inv[0][1]*Inv[1][0];
	for(int i=0;i<enc.size();i++)
	{
		int t1 = Inv[0][0]*enc[i].first + Inv[0][1]*enc[i].second;
		int t2 = Inv[1][0]*enc[i].first + Inv[1][1]*enc[i].second;
		int a = t1/det;
		int b = t2/det;
		P += arr[a];
		P += arr[b];
	}
	cout<<"\nplain text is: "<<P;
}

int main()
{
	for(int i=0;i<26;i++)
		arr[i] = char(65+i);
	int key[2][2];
	cout<<"enter a key matrix ";
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			cin>>key[i][j];
	int Inv[2][2];
	Inv[0][0] = key[1][1];
	Inv[0][1] = -key[0][1];
	Inv[1][0] = -key[1][0];
	Inv[1][1] = key[0][0];
	string msg;
	cout<<"enter plain text: ";
	cin>>msg;
	encryption(msg,key);
	decryption(Inv);
	return 0;
}







RSA ALGO:

#include <bits/stdc++.h>

using namespace std;

int gcd(int a, int b)
{
	if (b == 0)
		return a;
	return gcd(b, a % b);
}

double modInverse(int e, int phiN)
{
	int d = 0;
	while (d < phiN)
	{
		if ((e * d) % phiN == 1)
			return d;
		d++;
	}
	return 1;
}

int main()
{

	int p, q;

	cout << "enter p, q prime value ";
	cin >> p >> q;

	int n = p * q;
	int phiN = (p - 1) * (q - 1);

	int e = 2;

	while (e < phiN)
	{
		if (gcd(e, phiN) == 1)
			break;
		else
			e++;
	}
	int d = modInverse(e, phiN);
	int plaintext;
	int cipher = 1;
	cout << "\nEnter plaintext ";
	cin >> plaintext;
	for (int i = 0; i < e; i++)
	{
		cipher = (cipher * plaintext) % n;
	}

	cout << "cipher text is " << cipher << endl;
	//	plaintext = fmod(pow(cipher, d), n);
	int decrypt = 1;
	for (int i = 0; i < d; i++)
	{
		decrypt = (decrypt * cipher) % n;
	}
	cout << "plain text is " << decrypt << endl;
	return 0;
}
